

# Post-Confirmation Advisory Gate (Hardened)

## Summary

When a user confirms a system install year via chat, Habitta currently records the fact and stops. This creates a trust-eroding dead end: the system remembers but doesn't think forward.

This fix adds a mandatory post-confirmation advisory that re-computes lifecycle position and emits structured advisory facts -- which a formatting layer then renders into prose. The handler never generates narrative text directly.

Three refinements from the QA review are addressed:
1. Lifecycle math uses the calculator's own output (no re-derivation)
2. Advisory facts are structured data; prose is generated by a formatter
3. Confidence gates the advisory tone

---

## Architecture

Two files change. One new type is added to an existing interface.

| File | Role |
|------|------|
| `supabase/functions/ai-home-assistant/index.ts` | Emits structured advisory facts after successful `update_system_info` |
| `src/lib/chatFormatting.ts` | New formatter: `buildPostConfirmationAdvisoryMessage()` renders facts into prose |

---

## File 1: `supabase/functions/ai-home-assistant/index.ts`

### Where: `update_system_info` case (lines 1817-1831)

After the successful `update-system-install` call and before the `return JSON.stringify(...)`, add the post-confirmation lifecycle re-computation.

### Step 1: Re-compute lifecycle using the calculator

Use the property context already available in the handler's `context` object. This is the same data path used by `enrichSystemWithLifecycle()` (lines 480-541):

```text
const currentYear = new Date().getFullYear();
const installYear = parsedArgs.install_year;
const systemType = parsedArgs.system_type;

// Build inputs for the pure calculator
const propertyCtx: LifecyclePropertyContext = {
  yearBuilt: context.homeLocation?.yearBuilt || 2000,
  state: context.homeLocation?.state || 'FL',
  city: context.homeLocation?.city,
};
const region = getRegionContext(propertyCtx.state, propertyCtx.city);
const resolvedInstall: ResolvedInstallInput = {
  installYear: installYear,
  installSource: 'owner_reported',
  confidenceScore: 0.7,
  replacementStatus: parsedArgs.replacement_status || 'unknown',
  rationale: 'User confirmed via chat',
};

const lifecycle = calculateSystemLifecycle(systemType, resolvedInstall, propertyCtx, region);
```

### Step 2: Derive advisory tier from lifecycle output (Refinement #1)

The previous plan computed `expectedLifespan = likelyYear - installYear` which compounds uncertainty. Instead, derive everything from the calculator's replacement window directly:

```text
const age = installYear ? currentYear - installYear : null;
const likelyYear = lifecycle.replacementWindow.likelyYear;
const earlyYear = lifecycle.replacementWindow.earlyYear;
const remainingYears = likelyYear - currentYear;

// Expected lifespan derived FROM the calculator, not re-computed
const expectedLifespan = likelyYear - (installYear || propertyCtx.yearBuilt);

// Lifecycle ratio uses the same thresholds as enrichSystemWithLifecycle()
const earlyThreshold = earlyYear - (installYear || propertyCtx.yearBuilt);
const lifespanRatio = age !== null ? age / expectedLifespan : 0;
```

Advisory tiers (deterministic):

| Condition | Tier |
|-----------|------|
| `age >= expectedLifespan` (past likelyYear) | `late_life` |
| `age >= earlyThreshold` (past earlyYear) | `planning_window` |
| `age >= earlyThreshold * 0.5` | `mid_life` |
| Below | `early_life` |

This aligns exactly with the `enrichSystemWithLifecycle()` stage logic (lines 517-519), preventing dashboard/chat contradiction (Guardrail #5 from GUARDRAILS.md).

### Step 3: Build structured advisory facts (Refinement #2)

The handler returns structured data, NOT prose. This is the key architectural refinement.

```text
// Climate context label (calm, matter-of-fact)
const climateLabels: Record<string, string> = {
  coastal: 'coastal salt air and humidity',
  high_heat: 'high heat and humidity',
  freeze_thaw: 'freeze-thaw cycling',
  moderate: 'typical conditions',
};
```

The `postConfirmationAdvisory` is a pure data structure embedded in the existing `system_update` response envelope:

```text
postConfirmationAdvisory: {
  tier: 'late_life' | 'planning_window' | 'mid_life' | 'early_life',
  systemKey: string,            // e.g., 'water_heater'
  systemLabel: string,          // e.g., 'Water Heater' (from lifecycle.systemLabel)
  age: number | null,
  expectedLifespan: number,
  remainingYears: number,
  climateLabel: string,         // e.g., 'high heat and humidity'
  advisoryConfident: boolean,   // Refinement #3: confidence gate
  nowActions: string[],         // System-specific immediate actions
  planActions: string[],        // System-specific planning actions
  precisionCTA: string | null,  // e.g., 'Upload a photo of the manufacturer label...'
  closingIntent: string,        // e.g., 'explore_costs_or_remind'
}
```

### Step 4: Confidence gating (Refinement #3)

```text
const advisoryConfident =
  resolvedInstall.confidenceScore >= 0.7 &&
  // Region confidence check: use the resolved climate context
  (isResolvedClimateContext(region) ? region.climateConfidence !== 'low' : region.isHotHumid);
```

When `advisoryConfident === false`, the formatter will use softened language ("Based on the information available...") instead of declarative statements ("At ~16 years old in this climate..."). Same actions, different tone.

### Step 5: System-specific action content

Actions are defined per system type and tier. Only `late_life` and `planning_window` get proactive actions. `mid_life` and `early_life` get a lightweight status note only.

**Water Heater (late_life):**
- Now: "Visually inspect the base and fittings for moisture or corrosion", "Consider a preventive flush if it hasn't been done in the last year"
- Plan: "Begin replacement planning within the next 6-12 months", "Decide whether to stay with a standard tank or consider a heat-pump unit"
- Precision CTA: "Upload a photo of the manufacturer label so I can confirm capacity, efficiency, and exact model type"

**HVAC (late_life):**
- Now: "Schedule a professional efficiency check", "Replace air filter if overdue"
- Plan: "Begin replacement planning within the next 12 months", "Research SEER ratings appropriate for your climate"
- Precision CTA: "Upload a photo of the unit's data plate for exact model and efficiency details"

**Roof (late_life):**
- Now: "Inspect for missing or curling shingles from ground level", "Check attic for signs of moisture or daylight"
- Plan: "Get a professional roof assessment within the next year", "Begin budgeting for replacement"
- Precision CTA: null (roof material is typically determined from ATTOM or photos)

**planning_window** uses the same structure but softer plan language ("This is a reasonable window to start researching options").

**mid_life / early_life:** No actions. Just a status line ("well within its expected service life").

### Step 6: Updated response envelope

The existing `system_update` JSON response (lines 1821-1831) is extended with the advisory data:

```text
return JSON.stringify({
  type: 'system_update',
  success: true,
  systemKey: parsedArgs.system_type,
  alreadyRecorded: result.alreadyRecorded || false,
  installedLine: result.installedLine,
  confidenceLevel: result.confidenceLevel,
  message: result.alreadyRecorded
    ? `That's already recorded. Your ${parsedArgs.system_type} shows as ${result.installedLine}.`
    : result.message,
  // NEW: Structured advisory for post-confirmation formatting
  postConfirmationAdvisory: advisoryTier !== 'early_life' || advisoryTier !== 'mid_life'
    ? advisoryBlock
    : undefined,
});
```

The advisory is only included when tier is `late_life` or `planning_window`. For lighter tiers, a minimal block with just `tier` and `statusNote` is included.

### Guard: Only trigger when install_year is present and newly recorded

The advisory is skipped when:
- `result.alreadyRecorded === true` (no new info, no advisory needed)
- `parsedArgs.install_year` is null/undefined (replacement-status-only updates)
- The system type is not a recognized capital system (`hvac`, `roof`, `water_heater`)

---

## File 2: `src/lib/chatFormatting.ts`

### New type: `PostConfirmationAdvisoryData`

Added to the types section (after `SystemUpdateData`):

```text
export interface PostConfirmationAdvisoryData {
  tier: 'late_life' | 'planning_window' | 'mid_life' | 'early_life';
  systemKey: string;
  systemLabel: string;
  age: number | null;
  expectedLifespan: number;
  remainingYears: number;
  climateLabel: string;
  advisoryConfident: boolean;
  nowActions?: string[];
  planActions?: string[];
  precisionCTA?: string | null;
  closingIntent?: string;
  statusNote?: string;  // For mid_life/early_life tiers
}
```

### Extend `SystemUpdateData` interface

Add optional `postConfirmationAdvisory` field:

```text
export interface SystemUpdateData {
  // ...existing fields...
  postConfirmationAdvisory?: PostConfirmationAdvisoryData;
}
```

### New formatter: `buildPostConfirmationAdvisoryMessage()`

This function owns all narrative text. The handler never generates prose.

```text
function buildPostConfirmationAdvisoryMessage(advisory: PostConfirmationAdvisoryData): string {
  const parts: string[] = [];

  // Causal anchor: "Because this install date moves the system past..."
  if (advisory.tier === 'late_life' || advisory.tier === 'planning_window') {
    parts.push('Because this install date moves the system into its ' +
      (advisory.tier === 'late_life' ? 'late-life window' : 'planning window') +
      ", here's what matters next.");
  }

  // Status line (confidence-gated tone)
  if (advisory.tier === 'late_life') {
    if (advisory.advisoryConfident) {
      parts.push(`At ~${advisory.age} years old in ${advisory.climateLabel}, your ${advisory.systemLabel.toLowerCase()} is operating beyond the typical reliable window. It may continue to run, but failure risk increases at this stage.`);
    } else {
      parts.push(`Based on the information available, your ${advisory.systemLabel.toLowerCase()} at ~${advisory.age} years old may be approaching the end of its typical service life.`);
    }
  } else if (advisory.tier === 'planning_window') {
    if (advisory.advisoryConfident) {
      parts.push(`At ~${advisory.age} years old, your ${advisory.systemLabel.toLowerCase()} is entering its replacement planning window for ${advisory.climateLabel} conditions.`);
    } else {
      parts.push(`Based on the information available, your ${advisory.systemLabel.toLowerCase()} at ~${advisory.age} years old is approaching its typical planning window.`);
    }
  } else {
    // mid_life or early_life
    parts.push(advisory.statusNote ||
      `At ~${advisory.age} years old, your ${advisory.systemLabel.toLowerCase()} is well within its expected service life. Routine monitoring is sufficient.`);
    return parts.join('\n\n');
  }

  // Now actions
  if (advisory.nowActions?.length) {
    parts.push('**Now (low effort):**');
    parts.push(advisory.nowActions.map(a => `- ${a}`).join('\n'));
  }

  // Plan actions
  if (advisory.planActions?.length) {
    parts.push('**Plan ahead:**');
    parts.push(advisory.planActions.map(a => `- ${a}`).join('\n'));
  }

  // Precision CTA
  if (advisory.precisionCTA) {
    parts.push(`For more precision, you can ${advisory.precisionCTA.toLowerCase()}.`);
  }

  // Closing question
  const closingQuestions: Record<string, string> = {
    explore_costs_or_remind: 'Would you like to explore replacement costs, or set a reminder to revisit this?',
  };
  if (advisory.closingIntent && closingQuestions[advisory.closingIntent]) {
    parts.push(closingQuestions[advisory.closingIntent]);
  }

  return parts.join('\n\n');
}
```

### Update `buildSystemUpdateConfirmation()` (line 202)

The existing function generates the clerical confirmation ("I've saved that the water heater was installed in 2010..."). Extend it to append the advisory when present:

```text
function buildSystemUpdateConfirmation(data: SystemUpdateData): string {
  // ...existing confirmation logic (unchanged)...
  let confirmation = existingConfirmationLogic(data);

  // Append advisory if present
  if (data.postConfirmationAdvisory) {
    const advisory = buildPostConfirmationAdvisoryMessage(data.postConfirmationAdvisory);
    if (advisory) {
      confirmation += '\n\n' + advisory;
    }
  }

  return confirmation;
}
```

### Update `extractSystemUpdateData()` (line 242)

The extraction function must also pull `postConfirmationAdvisory` from the parsed JSON:

```text
systemUpdate = {
  success: data.success,
  systemKey: data.systemKey,
  alreadyRecorded: data.alreadyRecorded || false,
  installedLine: data.installedLine,
  confidenceLevel: data.confidenceLevel,
  message: data.message,
  reason: data.reason,
  // NEW: Pull advisory facts from tool result
  postConfirmationAdvisory: data.postConfirmationAdvisory,
};
```

No other changes to the extraction pipeline. The advisory data flows through the existing `system_update` type, which is already whitelisted in `DOMAIN_TYPES`.

---

## What This Changes (and What It Does NOT)

### Changes
- `ai-home-assistant/index.ts`: ~60 lines added to `update_system_info` case (lifecycle re-computation + advisory fact generation)
- `chatFormatting.ts`: ~80 lines added (new type, new formatter, extended extraction)

### Does NOT Change
- No prompt changes (this is a deterministic rule, not model behavior)
- No new edge functions
- No database changes
- No new domain types in the normalization layer (uses existing `system_update`)
- The `onSystemUpdated?.()` callback in ChatConsole already fires on successful updates
- Other tool handlers are unaffected

---

## Separation of Concerns (Refinement #2 -- Critical)

| Layer | Responsibility |
|-------|---------------|
| `ai-home-assistant` handler | Computes lifecycle facts, determines tier, builds structured advisory data |
| `chatFormatting.ts` formatter | Owns all narrative text, tone gating, markdown formatting |
| `ChatConsole.tsx` | Unchanged -- receives formatted text via existing extraction pipeline |

The handler never writes a sentence. The formatter never computes lifecycle math. This separation means copy can evolve independently of logic.

---

## Confidence Gating (Refinement #3)

The `advisoryConfident` boolean gates tone, not content:

| `advisoryConfident` | Status copy pattern |
|---------------------|-------------------|
| `true` | "At ~16 years old in this climate, your water heater is operating beyond..." |
| `false` | "Based on the information available, your water heater at ~16 years old may be approaching..." |

Same actions in both cases. Only the status line changes. This prevents overconfidence when the install source is weak or the climate is inferred at state-only granularity.

---

## Home context: `yearBuilt` availability

The handler's `context` object has `homeLocation` with `city` and `state` (lines 596-602), but `yearBuilt` is not currently passed through. The `home` query (line 557) fetches `year_built`, but it's mapped to `homeLocation` without `yearBuilt`.

Fix: Add `yearBuilt` to the context's `homeLocation` object in `getPropertyContext()`. This is a 1-line addition to the return object (line 597):

```text
homeLocation: home ? {
  lat: home.latitude,
  lng: home.longitude,
  city: home.city,
  state: home.state,
  zipCode: home.zip_code,
  yearBuilt: home.year_built,  // NEW: needed for lifecycle re-computation
} : null,
```

This is the cleanest fix -- it makes the already-fetched data available without a new query.

---

## Implementation Order

1. `ai-home-assistant/index.ts` -- Add `yearBuilt` to context + advisory fact generation in `update_system_info`
2. `chatFormatting.ts` -- New type, new formatter, extended extraction
3. Deploy and test with water heater (2010 in FL), HVAC, and roof scenarios

---

## Example Output (Water Heater, 2010, Florida)

```text
I've saved that the water heater was installed in 2010 (owner-reported).
You'll see it reflected in your system timeline.

Because this install date moves the system into its late-life window,
here's what matters next.

At ~16 years old in high heat and humidity, your water heater is
operating beyond the typical reliable window. It may continue to run,
but failure risk increases at this stage.

**Now (low effort):**
- Visually inspect the base and fittings for moisture or corrosion
- Consider a preventive flush if it hasn't been done in the last year

**Plan ahead:**
- Begin replacement planning within the next 6-12 months
- Decide whether to stay with a standard tank or consider a heat-pump unit

For more precision, you can upload a photo of the manufacturer label
so I can confirm capacity, efficiency, and exact model type.

Would you like to explore replacement costs, or set a reminder to
revisit this?
```

